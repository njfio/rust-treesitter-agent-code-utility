//! Real vulnerability database integration
//! 
//! Integrates with NVD, OSV, and GitHub Security Advisory APIs
//! to provide real vulnerability detection and assessment.

use crate::infrastructure::{HttpClient, RequestConfig, AuthConfig, DatabaseManager, VulnerabilityRecord, MultiServiceRateLimiter, Cache};
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use tracing::{info, debug, warn};
use anyhow::Result;
use uuid::Uuid;

/// Real vulnerability database client
#[derive(Clone)]
pub struct VulnerabilityDatabase {
    http_client: HttpClient,
    database: DatabaseManager,
    cache: Cache,
    rate_limiter: MultiServiceRateLimiter,
    nvd_config: NvdConfig,
    osv_config: OsvConfig,
    github_config: GitHubConfig,
}

/// NVD API configuration
#[derive(Debug, Clone)]
pub struct NvdConfig {
    pub base_url: String,
    pub api_key: Option<String>,
    pub enabled: bool,
}

/// OSV API configuration
#[derive(Debug, Clone)]
pub struct OsvConfig {
    pub base_url: String,
    pub enabled: bool,
}

/// GitHub Security Advisory configuration
#[derive(Debug, Clone)]
pub struct GitHubConfig {
    pub base_url: String,
    pub token: Option<String>,
    pub enabled: bool,
}

/// NVD API response structure
#[derive(Debug, Deserialize)]
pub struct NvdResponse {
    #[serde(rename = "vulnerabilities")]
    pub vulnerabilities: Vec<NvdVulnerability>,
    #[serde(rename = "totalResults")]
    pub total_results: u32,
    #[serde(rename = "resultsPerPage")]
    pub results_per_page: u32,
    #[serde(rename = "startIndex")]
    pub start_index: u32,
}

/// NVD vulnerability structure
#[derive(Debug, Deserialize)]
pub struct NvdVulnerability {
    pub cve: NvdCve,
}

/// NVD CVE structure
#[derive(Debug, Deserialize)]
pub struct NvdCve {
    pub id: String,
    #[serde(rename = "sourceIdentifier")]
    pub source_identifier: Option<String>,
    pub published: String,
    #[serde(rename = "lastModified")]
    pub last_modified: String,
    #[serde(rename = "vulnStatus")]
    pub vuln_status: Option<String>,
    pub descriptions: Vec<NvdDescription>,
    pub metrics: Option<NvdMetrics>,
    pub weaknesses: Option<Vec<NvdWeakness>>,
    pub configurations: Option<Vec<NvdConfiguration>>,
    pub references: Option<Vec<NvdReference>>,
}

/// NVD description structure
#[derive(Debug, Deserialize)]
pub struct NvdDescription {
    pub lang: String,
    pub value: String,
}

/// NVD metrics structure
#[derive(Debug, Deserialize)]
pub struct NvdMetrics {
    #[serde(rename = "cvssMetricV31")]
    pub cvss_metric_v31: Option<Vec<NvdCvssMetric>>,
    #[serde(rename = "cvssMetricV30")]
    pub cvss_metric_v30: Option<Vec<NvdCvssMetric>>,
    #[serde(rename = "cvssMetricV2")]
    pub cvss_metric_v2: Option<Vec<NvdCvssMetricV2>>,
}

/// NVD CVSS metric structure
#[derive(Debug, Deserialize)]
pub struct NvdCvssMetric {
    pub source: String,
    pub type_field: String,
    #[serde(rename = "cvssData")]
    pub cvss_data: NvdCvssData,
    #[serde(rename = "exploitabilityScore")]
    pub exploitability_score: Option<f64>,
    #[serde(rename = "impactScore")]
    pub impact_score: Option<f64>,
}

/// NVD CVSS data structure
#[derive(Debug, Deserialize)]
pub struct NvdCvssData {
    pub version: String,
    #[serde(rename = "vectorString")]
    pub vector_string: String,
    #[serde(rename = "accessVector")]
    pub access_vector: Option<String>,
    #[serde(rename = "accessComplexity")]
    pub access_complexity: Option<String>,
    pub authentication: Option<String>,
    #[serde(rename = "confidentialityImpact")]
    pub confidentiality_impact: Option<String>,
    #[serde(rename = "integrityImpact")]
    pub integrity_impact: Option<String>,
    #[serde(rename = "availabilityImpact")]
    pub availability_impact: Option<String>,
    #[serde(rename = "baseScore")]
    pub base_score: f64,
    #[serde(rename = "baseSeverity")]
    pub base_severity: Option<String>,
}

/// NVD CVSS metric V2 structure
#[derive(Debug, Deserialize)]
pub struct NvdCvssMetricV2 {
    pub source: String,
    pub type_field: String,
    #[serde(rename = "cvssData")]
    pub cvss_data: NvdCvssData,
    #[serde(rename = "baseSeverity")]
    pub base_severity: Option<String>,
    #[serde(rename = "exploitabilityScore")]
    pub exploitability_score: Option<f64>,
    #[serde(rename = "impactScore")]
    pub impact_score: Option<f64>,
    #[serde(rename = "acInsufInfo")]
    pub ac_insuf_info: Option<bool>,
    #[serde(rename = "obtainAllPrivilege")]
    pub obtain_all_privilege: Option<bool>,
    #[serde(rename = "obtainUserPrivilege")]
    pub obtain_user_privilege: Option<bool>,
    #[serde(rename = "obtainOtherPrivilege")]
    pub obtain_other_privilege: Option<bool>,
    #[serde(rename = "userInteractionRequired")]
    pub user_interaction_required: Option<bool>,
}

/// NVD weakness structure
#[derive(Debug, Deserialize)]
pub struct NvdWeakness {
    pub source: String,
    pub type_field: String,
    pub description: Vec<NvdDescription>,
}

/// NVD configuration structure
#[derive(Debug, Deserialize)]
pub struct NvdConfiguration {
    pub nodes: Vec<NvdNode>,
}

/// NVD node structure
#[derive(Debug, Deserialize)]
pub struct NvdNode {
    pub operator: String,
    #[serde(rename = "negate")]
    pub negate: Option<bool>,
    #[serde(rename = "cpeMatch")]
    pub cpe_match: Option<Vec<NvdCpeMatch>>,
}

/// NVD CPE match structure
#[derive(Debug, Deserialize)]
pub struct NvdCpeMatch {
    pub vulnerable: bool,
    pub criteria: String,
    #[serde(rename = "versionStartIncluding")]
    pub version_start_including: Option<String>,
    #[serde(rename = "versionStartExcluding")]
    pub version_start_excluding: Option<String>,
    #[serde(rename = "versionEndIncluding")]
    pub version_end_including: Option<String>,
    #[serde(rename = "versionEndExcluding")]
    pub version_end_excluding: Option<String>,
}

/// NVD reference structure
#[derive(Debug, Deserialize)]
pub struct NvdReference {
    pub url: String,
    pub source: Option<String>,
    pub tags: Option<Vec<String>>,
}

/// OSV API request structure
#[derive(Debug, Serialize)]
pub struct OsvRequest {
    pub package: OsvPackage,
    pub version: Option<String>,
}

/// OSV package structure
#[derive(Debug, Serialize, Deserialize)]
pub struct OsvPackage {
    pub name: String,
    pub ecosystem: String,
}

/// OSV API response structure
#[derive(Debug, Deserialize)]
pub struct OsvResponse {
    pub vulns: Vec<OsvVulnerability>,
}

/// OSV vulnerability structure
#[derive(Debug, Deserialize)]
pub struct OsvVulnerability {
    pub id: String,
    pub summary: Option<String>,
    pub details: Option<String>,
    pub aliases: Option<Vec<String>>,
    pub modified: String,
    pub published: Option<String>,
    pub database_specific: Option<serde_json::Value>,
    pub ecosystem_specific: Option<serde_json::Value>,
    pub severity: Option<Vec<OsvSeverity>>,
    pub affected: Option<Vec<OsvAffected>>,
    pub references: Option<Vec<OsvReference>>,
}

/// OSV severity structure
#[derive(Debug, Deserialize)]
pub struct OsvSeverity {
    pub type_field: String,
    pub score: String,
}

/// OSV affected structure
#[derive(Debug, Deserialize)]
pub struct OsvAffected {
    pub package: OsvPackage,
    pub ranges: Option<Vec<OsvRange>>,
    pub versions: Option<Vec<String>>,
    pub ecosystem_specific: Option<serde_json::Value>,
    pub database_specific: Option<serde_json::Value>,
}

/// OSV range structure
#[derive(Debug, Deserialize)]
pub struct OsvRange {
    pub type_field: String,
    pub events: Vec<OsvEvent>,
}

/// OSV event structure
#[derive(Debug, Deserialize)]
pub struct OsvEvent {
    pub introduced: Option<String>,
    pub fixed: Option<String>,
    pub last_affected: Option<String>,
    pub limit: Option<String>,
}

/// OSV reference structure
#[derive(Debug, Deserialize)]
pub struct OsvReference {
    pub type_field: Option<String>,
    pub url: String,
}

/// GitHub Security Advisory API response structure
#[derive(Debug, Deserialize)]
pub struct GitHubResponse {
    pub advisories: Vec<GitHubAdvisory>,
}

/// GitHub advisory structure
#[derive(Debug, Deserialize)]
pub struct GitHubAdvisory {
    pub ghsa_id: String,
    pub cve_id: Option<String>,
    pub summary: Option<String>,
    pub description: Option<String>,
    pub severity: Option<String>,
    pub cvss_score: Option<f64>,
    pub references: Option<Vec<String>>,
    pub cwes: Option<Vec<String>>,
    pub published_at: String,
    pub updated_at: String,
}

impl VulnerabilityDatabase {
    /// Create a new vulnerability database client
    pub async fn new(
        database: DatabaseManager,
        cache: Cache,
        rate_limiter: MultiServiceRateLimiter,
        nvd_config: NvdConfig,
        osv_config: OsvConfig,
        github_config: GitHubConfig,
    ) -> Result<Self> {
        let http_client = HttpClient::new()?;

        Ok(Self {
            http_client,
            database,
            cache,
            rate_limiter,
            nvd_config,
            osv_config,
            github_config,
        })
    }

    /// Check for vulnerabilities in a package
    pub async fn check_package_vulnerabilities(
        &self,
        package_name: &str,
        version: Option<&str>,
        ecosystem: &str,
    ) -> Result<Vec<VulnerabilityRecord>> {
        let mut vulnerabilities = Vec::new();

        // Check cache first
        let cache_key = format!("vuln_{}_{}_{}_{}", 
                               package_name, 
                               version.unwrap_or("latest"), 
                               ecosystem,
                               chrono::Utc::now().format("%Y-%m-%d"));

        if let Ok(Some(cached_vulns)) = self.cache.get::<Vec<VulnerabilityRecord>>(&cache_key).await {
            debug!("Found cached vulnerabilities for {}", package_name);
            return Ok(cached_vulns);
        }

        // Check local database
        let db_vulns = self.database.get_vulnerabilities_for_package(package_name).await?;
        if !db_vulns.is_empty() {
            debug!("Found {} vulnerabilities in local database for {}", db_vulns.len(), package_name);
            vulnerabilities.extend(db_vulns);
        }

        // Query external APIs
        if self.osv_config.enabled {
            match self.query_osv_api(package_name, version, ecosystem).await {
                Ok(osv_vulns) => {
                    info!("Found {} vulnerabilities from OSV for {}", osv_vulns.len(), package_name);
                    vulnerabilities.extend(osv_vulns);
                }
                Err(e) => warn!("OSV API query failed for {}: {}", package_name, e),
            }
        }

        if self.nvd_config.enabled {
            match self.query_nvd_api(package_name).await {
                Ok(nvd_vulns) => {
                    info!("Found {} vulnerabilities from NVD for {}", nvd_vulns.len(), package_name);
                    vulnerabilities.extend(nvd_vulns);
                }
                Err(e) => warn!("NVD API query failed for {}: {}", package_name, e),
            }
        }

        if self.github_config.enabled {
            match self.query_github_api(package_name, ecosystem).await {
                Ok(gh_vulns) => {
                    info!("Found {} vulnerabilities from GitHub for {}", gh_vulns.len(), package_name);
                    vulnerabilities.extend(gh_vulns);
                }
                Err(e) => warn!("GitHub API query failed for {}: {}", package_name, e),
            }
        }

        // Deduplicate vulnerabilities
        vulnerabilities = self.deduplicate_vulnerabilities(vulnerabilities);

        // Cache results
        if let Err(e) = self.cache.set_with_ttl(&cache_key, &vulnerabilities, std::time::Duration::from_secs(3600)).await {
            warn!("Failed to cache vulnerabilities for {}: {}", package_name, e);
        }

        // Store in database for future use
        for vuln in &vulnerabilities {
            if let Err(e) = self.database.store_vulnerability(vuln).await {
                warn!("Failed to store vulnerability {} in database: {}", vuln.cve_id, e);
            }
        }

        Ok(vulnerabilities)
    }

    /// Query OSV API for vulnerabilities
    async fn query_osv_api(
        &self,
        package_name: &str,
        version: Option<&str>,
        ecosystem: &str,
    ) -> Result<Vec<VulnerabilityRecord>> {
        // Wait for rate limit
        self.rate_limiter.wait_for_permit("osv").await?;

        let request = OsvRequest {
            package: OsvPackage {
                name: package_name.to_string(),
                ecosystem: ecosystem.to_string(),
            },
            version: version.map(|v| v.to_string()),
        };

        let url = format!("{}/v1/query", self.osv_config.base_url);
        let response = self.http_client.post(&url, Some(&request), None).await?;
        
        let osv_response: OsvResponse = serde_json::from_str(&response.body)?;
        
        let mut vulnerabilities = Vec::new();
        for osv_vuln in osv_response.vulns {
            let vuln_record = self.convert_osv_to_record(osv_vuln, package_name)?;
            vulnerabilities.push(vuln_record);
        }

        Ok(vulnerabilities)
    }

    /// Query NVD API for vulnerabilities
    async fn query_nvd_api(&self, package_name: &str) -> Result<Vec<VulnerabilityRecord>> {
        // Wait for rate limit
        self.rate_limiter.wait_for_permit("nvd").await?;

        let mut config = RequestConfig::default();
        if let Some(api_key) = &self.nvd_config.api_key {
            config.auth = Some(AuthConfig::ApiKey {
                key: api_key.clone(),
                header: "apiKey".to_string(),
            });
        }

        let url = format!("{}/cves/2.0?keywordSearch={}", self.nvd_config.base_url, package_name);
        let response = self.http_client.get(&url, Some(config)).await?;
        
        let nvd_response: NvdResponse = serde_json::from_str(&response.body)?;
        
        let mut vulnerabilities = Vec::new();
        for nvd_vuln in nvd_response.vulnerabilities {
            let vuln_record = self.convert_nvd_to_record(nvd_vuln, package_name)?;
            vulnerabilities.push(vuln_record);
        }

        Ok(vulnerabilities)
    }

    /// Query GitHub Security Advisory API for vulnerabilities
    async fn query_github_api(
        &self,
        package_name: &str,
        ecosystem: &str,
    ) -> Result<Vec<VulnerabilityRecord>> {
        self.rate_limiter.wait_for_permit("github").await?;

        let mut config = RequestConfig::default();
        if let Some(token) = &self.github_config.token {
            config.auth = Some(AuthConfig::Bearer(token.clone()));
        }

        let url = format!("{}/advisories?package={}&ecosystem={}", self.github_config.base_url, package_name, ecosystem);
        let response = self.http_client.get(&url, Some(config)).await?;

        let gh_response: GitHubResponse = serde_json::from_str(&response.body)?;
        let mut vulnerabilities = Vec::new();
        for adv in gh_response.advisories {
            let rec = self.convert_github_to_record(adv, package_name)?;
            vulnerabilities.push(rec);
        }

        Ok(vulnerabilities)
    }

    /// Convert OSV vulnerability to VulnerabilityRecord
    fn convert_osv_to_record(&self, osv_vuln: OsvVulnerability, package_name: &str) -> Result<VulnerabilityRecord> {
        let now = Utc::now();
        let published_date = osv_vuln.published
            .as_ref()
            .and_then(|p| DateTime::parse_from_rfc3339(p).ok())
            .map(|dt| dt.with_timezone(&Utc))
            .unwrap_or(now);

        let last_modified = DateTime::parse_from_rfc3339(&osv_vuln.modified)
            .map(|dt| dt.with_timezone(&Utc))
            .unwrap_or(now);

        let severity = osv_vuln.severity
            .as_ref()
            .and_then(|s| s.first())
            .map(|s| s.score.clone())
            .unwrap_or_else(|| "UNKNOWN".to_string());

        let cvss_score = self.extract_cvss_score_from_severity(&severity);

        let references = osv_vuln.references
            .map(|refs| refs.into_iter().map(|r| r.url).collect::<Vec<_>>())
            .unwrap_or_default();

        let cwe_ids = osv_vuln.aliases
            .unwrap_or_default()
            .into_iter()
            .filter(|alias| alias.starts_with("CWE-"))
            .collect::<Vec<_>>();

        Ok(VulnerabilityRecord {
            id: Uuid::new_v4().to_string(),
            cve_id: osv_vuln.id,
            package_name: package_name.to_string(),
            affected_versions: "Unknown".to_string(), // Would need to parse from affected field
            severity,
            cvss_score,
            description: osv_vuln.summary.unwrap_or_else(|| "No description available".to_string()),
            published_date,
            last_modified,
            references: serde_json::to_string(&references)?,
            cwe_ids: serde_json::to_string(&cwe_ids)?,
            created_at: now,
            updated_at: now,
        })
    }

    /// Convert NVD vulnerability to VulnerabilityRecord
    fn convert_nvd_to_record(&self, nvd_vuln: NvdVulnerability, package_name: &str) -> Result<VulnerabilityRecord> {
        let now = Utc::now();
        let cve = nvd_vuln.cve;

        let published_date = DateTime::parse_from_rfc3339(&cve.published)
            .map(|dt| dt.with_timezone(&Utc))
            .unwrap_or(now);

        let last_modified = DateTime::parse_from_rfc3339(&cve.last_modified)
            .map(|dt| dt.with_timezone(&Utc))
            .unwrap_or(now);

        let description = cve.descriptions
            .into_iter()
            .find(|d| d.lang == "en")
            .map(|d| d.value)
            .unwrap_or_else(|| "No description available".to_string());

        let (severity, cvss_score) = self.extract_cvss_info(&cve.metrics);

        let references = cve.references
            .map(|refs| refs.into_iter().map(|r| r.url).collect::<Vec<_>>())
            .unwrap_or_default();

        let cwe_ids = cve.weaknesses
            .map(|weaknesses| {
                weaknesses.into_iter()
                    .flat_map(|w| w.description.into_iter())
                    .filter(|d| d.lang == "en")
                    .map(|d| d.value)
                    .collect::<Vec<_>>()
            })
            .unwrap_or_default();

        Ok(VulnerabilityRecord {
            id: Uuid::new_v4().to_string(),
            cve_id: cve.id,
            package_name: package_name.to_string(),
            affected_versions: "Unknown".to_string(), // Would need to parse from configurations
            severity,
            cvss_score,
            description,
            published_date,
            last_modified,
            references: serde_json::to_string(&references)?,
            cwe_ids: serde_json::to_string(&cwe_ids)?,
            created_at: now,
            updated_at: now,
        })
    }

    /// Convert GitHub advisory to VulnerabilityRecord
    fn convert_github_to_record(&self, adv: GitHubAdvisory, package_name: &str) -> Result<VulnerabilityRecord> {
        let now = Utc::now();
        let published_date = DateTime::parse_from_rfc3339(&adv.published_at)
            .map(|dt| dt.with_timezone(&Utc))
            .unwrap_or(now);
        let last_modified = DateTime::parse_from_rfc3339(&adv.updated_at)
            .map(|dt| dt.with_timezone(&Utc))
            .unwrap_or(now);

        let references = adv.references.unwrap_or_default();
        let cwe_ids = adv.cwes.unwrap_or_default();

        Ok(VulnerabilityRecord {
            id: Uuid::new_v4().to_string(),
            cve_id: adv.cve_id.unwrap_or(adv.ghsa_id),
            package_name: package_name.to_string(),
            affected_versions: "Unknown".to_string(),
            severity: adv.severity.unwrap_or_else(|| "UNKNOWN".to_string()),
            cvss_score: adv.cvss_score,
            description: adv.summary.unwrap_or_else(|| "No description available".to_string()),
            published_date,
            last_modified,
            references: serde_json::to_string(&references)?,
            cwe_ids: serde_json::to_string(&cwe_ids)?,
            created_at: now,
            updated_at: now,
        })
    }

    /// Extract CVSS information from NVD metrics
    fn extract_cvss_info(&self, metrics: &Option<NvdMetrics>) -> (String, Option<f64>) {
        if let Some(metrics) = metrics {
            // Try CVSS v3.1 first
            if let Some(cvss_v31) = &metrics.cvss_metric_v31 {
                if let Some(metric) = cvss_v31.first() {
                    return (
                        metric.cvss_data.base_severity.clone().unwrap_or_else(|| "UNKNOWN".to_string()),
                        Some(metric.cvss_data.base_score),
                    );
                }
            }

            // Try CVSS v3.0
            if let Some(cvss_v30) = &metrics.cvss_metric_v30 {
                if let Some(metric) = cvss_v30.first() {
                    return (
                        metric.cvss_data.base_severity.clone().unwrap_or_else(|| "UNKNOWN".to_string()),
                        Some(metric.cvss_data.base_score),
                    );
                }
            }

            // Try CVSS v2
            if let Some(cvss_v2) = &metrics.cvss_metric_v2 {
                if let Some(metric) = cvss_v2.first() {
                    return (
                        metric.base_severity.clone().unwrap_or_else(|| "UNKNOWN".to_string()),
                        Some(metric.cvss_data.base_score),
                    );
                }
            }
        }

        ("UNKNOWN".to_string(), None)
    }

    /// Extract CVSS score from severity string
    fn extract_cvss_score_from_severity(&self, severity: &str) -> Option<f64> {
        // Try to parse CVSS score from severity string
        if let Ok(score) = severity.parse::<f64>() {
            Some(score)
        } else {
            // Map severity levels to approximate scores
            match severity.to_uppercase().as_str() {
                "CRITICAL" => Some(9.0),
                "HIGH" => Some(7.0),
                "MEDIUM" => Some(5.0),
                "LOW" => Some(3.0),
                _ => None,
            }
        }
    }

    /// Deduplicate vulnerabilities by CVE ID
    fn deduplicate_vulnerabilities(&self, vulnerabilities: Vec<VulnerabilityRecord>) -> Vec<VulnerabilityRecord> {
        let mut seen_cves = std::collections::HashSet::new();
        let mut deduplicated = Vec::new();

        for vuln in vulnerabilities {
            if seen_cves.insert(vuln.cve_id.clone()) {
                deduplicated.push(vuln);
            }
        }

        deduplicated
    }

    /// Get vulnerability statistics
    pub async fn get_vulnerability_stats(&self) -> Result<VulnerabilityStats> {
        let db_stats = self.database.get_stats().await?;

        Ok(VulnerabilityStats {
            total_vulnerabilities: db_stats.vulnerability_count,
            critical_count: 0, // Would need to query by severity
            high_count: 0,
            medium_count: 0,
            low_count: 0,
            last_updated: Utc::now(),
        })
    }
}

/// Vulnerability statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityStats {
    pub total_vulnerabilities: u64,
    pub critical_count: u64,
    pub high_count: u64,
    pub medium_count: u64,
    pub low_count: u64,
    pub last_updated: DateTime<Utc>,
}
